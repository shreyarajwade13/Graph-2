"""
DFS Approach -
TC - O(n^2) ==> n^2 since we are running dfs only when n = -1 , else it wouldve been n * n^2
SC - O(n)
"""
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        if graph is None or len(graph) == 0: return -1

        n = len(graph)
        # step 1: create colors array
        colors = [-1 for i in range(n)]

        # step 2: set colors for each node in a distinct series
        color = 0

        def dfs(graph, color, colors, i):
            # base
            if colors[i] != -1: return

            # logic
            # assign the first node the 0th color, inrcementing as we move forward
            colors[i] = color
            # perform dfs --> go to connected nodes of the current node
            for j in range(n):
                if graph[i][j] == 1:
                    dfs(graph, color, colors, j)

        # call dfs
        for i in range(n):
            if colors[i] == -1:
                dfs(graph, color, colors, i)
                color += 1

        # step 3: form groups array of len(numColor) to identify how many nodes in each series
        groups = [0 for i in range(color)]
        for i in range(n):
            # we grab the value from colors array and assign it to index variable.
            # every time same color appears we increment the value at the group's index in groups array
            index = colors[i]
            groups[index] += 1

        # step 4: we find out how many nodes infected in each series
        initinfected = [0 for i in range(color)]
        # we check value from initial array, lets call it index,
        # we go to colors array and grab the value at that index i.e. colors[index]
        # and we do initinfected[colors[index]] += 1
        for i in range(len(initial)):
            index = initial[i]
            initinfected[colors[index]] += 1

        # print(colors)
        # print(groups)
        # print(initinfected)

        # step 5: check which nodes malware can be removed to save max nodes
        # case 1 - distinct number of nodes in each series -->  we remove malware from 1 node and we can save n number of nodes
        # case 2 - the number of nodes that can be saved in two series are the same, in that case, we choose the one with lower index
        # case 3 - none of the nodes can be saved, so we choose the lowest value from initial
        answer = float('inf')
        for i in range(len(initial)):
            # get the color from the colors array for each value in initial
            colr = colors[initial[i]]
            # case 1: check if number of infected nodes for this colr is 1
            if initinfected[colr] == 1:
                if answer == float('inf'):
                    answer = initial[i]
                # case 1 extended: if more than 1 series has ONLY 1 infected node, we check how many nodes can be saved in each case
                # to check how many nodes in each series, we check groups
                elif(groups[colors[initial[i]]] > groups[colors[answer]]):
                    answer = initial[i]
                # case 2: mentioned above
                elif((groups[colors[initial[i]]] == groups[colors[answer]]) and initial[i] < answer):
                    answer = initial[i]
        # case 3: mentioned above
        if answer == float('inf'):
            minVal = float('inf')
            for i in range(len(initial)):
                minVal = min(minVal, initial[i])
            return minVal

        return answer  